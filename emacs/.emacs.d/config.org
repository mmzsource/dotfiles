#+TITLE: Emacs Configuration
#+AUTHOR: M.Metz

* Introduction

The emacs-lisp code in this file will run when emacs starts. A great use case
for [[https://en.wikipedia.org/wiki/Literate_programming]['literate programming']] imho.

Mostly inspired by / copied from:

- [[https://github.com/hrs/dotfiles][hrs]]
- [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][sachac]]
- [[https://github.com/danielmai/.emacs.d/blob/master/config.org][danielmai]]

with a bunch of personal extensions and flavors.

* Installing Emacs

On macOS, I use [[http://brew.sh/][homebrew]] to install emacs.

Check "brew info emacs" to see if install options are still valid.

#+begin_src sh
brew install emacs --build-from-source --with-cocoa --with-gnutls --with-imagemagick@6
#+end_src

- ~--build-from-source~ to prevent dependency problem with jpeg library
- ~-with-cocoa~ to enable the emacs.app
- ~--with-gnutls~ to enable setting up secure communication
- ~--with-imagemagick@6~ to work with images

Create a symbolic link to emacs from the application directory:

#+begin_src sh
ln -s /usr/local/Cellar/emacs/25.3/Emacs.app ~/Applications/
#+end_src

Other option:

1. $ open /usr/local/Cellar/emacs/[version]/
2. Right-click Emacs.app and choose Make Alias.
3. Drag or move or copy the alias to Applications.
4. Rename the alias in your Applications folder to your desired name

Now emacs will also be found by spotlight.

#+BEGIN_SRC sh
brew install aspell --with-lang-nl
#+END_SRC

- aspell is needed for spell checking
- english language is installed by default (no need to specify)

* Override Defaults
** UI
*** (No) Menu & (no) scroll bar

I have never felt the need to use the menu or the scroll bar in emacs.

#+begin_src emacs-lisp
(tool-bar-mode 0)
(menu-bar-mode 0)
(when window-system
  (scroll-bar-mode -1))
(setq scroll-conservatively 100)
#+end_src

The 'scroll-conservatively' makes sure emacs doesn't recenter the cursor after
scrolling.

*** Window Size

I like this as a default size for my emacs app window:

#+begin_src emacs-lisp
(when window-system
  (set-frame-size (selected-frame) 112 56))
#+end_src

Keybindings to resize windows within emacs app window:

#+begin_src emacs-lisp
(bind-key "C-c C-<left>"  'shrink-window-horizontally)
(bind-key "C-c C-<right>" 'enlarge-window-horizontally)
(bind-key "C-c C-<down>"  'shrink-window)
(bind-key "C-c C-<up>"    'enlarge-window)
#+end_src

Unfortunately, the order of the '(no) menu & (no) scroll bar' paragraph and the
'window size' paragraph is important. If you change the order (window size
first), the window size will be the standard emacs window size, not the
specified size.

In addition, since I've activated 'save-desktop', emacs will remember the
settings of my last session. Therefore, this windowsize will only be used when
starting emacs from the terminal with the =--no-desktop= switch.

*** Font Size and Resizing

Resize text in every buffer and also in modeline. Also increases app window.
Default zoom bindings still work (=C-x C-+= etc.)

#+BEGIN_SRC emacs-lisp
(setq mmz/default-font "Menlo")
(setq mmz/default-font-size 14)
(setq mmz/current-font-size mmz/default-font-size)

(setq mmz/font-change-increment 1.1)

(defun mmz/font-code ()
  "Return a string representing the current font (like \"Menlo-14\")."
  (concat mmz/default-font "-" (number-to-string mmz/current-font-size)))

(defun mmz/set-font-size ()
  "Set the font to `mmz/default-font' at `mmz/current-font-size'.
   Set that for the current frame, and also make it the default for
   other, future frames."
  (let ((font-code (mmz/font-code)))
    (add-to-list 'default-frame-alist (cons 'font font-code))
    (set-frame-font font-code)))

(defun mmz/reset-font-size ()
  "Change font size back to `mmz/default-font-size'."
  (interactive)
  (setq mmz/current-font-size mmz/default-font-size)
  (mmz/set-font-size))

(defun mmz/increase-font-size ()
  "Increase current font size by a factor of `mmz/font-change-increment'."
  (interactive)
  (setq mmz/current-font-size
        (ceiling (* mmz/current-font-size mmz/font-change-increment)))
  (mmz/set-font-size))

(defun mmz/decrease-font-size ()
  "Decrease current font size by a factor of `mmz/font-change-increment', down to a minimum size of 1."
  (interactive)
  (setq mmz/current-font-size
        (max 1
             (floor (/ mmz/current-font-size mmz/font-change-increment))))
  (mmz/set-font-size))

(define-key global-map (kbd "C-)") 'mmz/reset-font-size)
(define-key global-map (kbd "C-+") 'mmz/increase-font-size)
(define-key global-map (kbd "C-=") 'mmz/increase-font-size)
(define-key global-map (kbd "C-_") 'mmz/decrease-font-size)
(define-key global-map (kbd "C--") 'mmz/decrease-font-size)

(mmz/reset-font-size)
#+END_SRC

*** Highlight current line

Softly highlight the current line:

#+begin_src emacs-lisp
(when window-system
  (global-hl-line-mode))
#+end_src

*** Disable annoying (visible) bells

[[http://stackoverflow.com/questions/11679700/emacs-disable-beep-when-trying-to-move-beyond-the-end-of-the-document][Disable Annoying Alarms]]

#+begin_src emacs-lisp
(defun my-bell-function ())
(setq ring-bell-function 'my-bell-function)
(setq visible-bell nil)
#+end_src

*** Wrap paragraphs automatically

AutoFillMode automatically wraps paragraphs. If you prefer to do it manually
disable this code and hit =M-q= with the cursor in the paragraph you want to
wrap.

Toggles wrapping with =C-c q=

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'gfm-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(global-set-key (kbd "C-c q") 'auto-fill-mode)
#+end_src

*** Themes

The [[https://github.com/bbatsov/solarized-emacs/][bbatsov solarized theme]] is quite easy on the eyes. However, I like the
default emacs theme. Therefore, I only load solarized when needed / wanted
with =M-x load-theme= (If I want solarized-dark as default, I'll have to add
=(load-theme 'solarized-dark t)= to this config)

Since I'm saving my desktop when closing emacs, an applied theme will also be
loaded when restarting emacs. To be able to 'reload' the default theme, I've
started =emacs --no-desktop=, started the theme editor with =M-x
customize-create-theme= and saved that theme as 'default'.

So after applying another theme, I can now always return to my default theme by
=M-x load-theme default=.

#+begin_src emacs-lisp
(use-package solarized-theme
  :defer 10
  :init
  (setq solarized-use-variable-pitch  nil)
  (setq solarized-scale-org-headlines nil)
  :ensure t)
#+end_src

*** Fancy Lambda's

Eye candy:

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
#+END_SRC

** Sensible defaults

I use most of [[https://github.com/hrs/sensible-defaults.el][sensible defaults]] for basic settings, but I decided to inline
it into this file, to reduce the *magic*.

#+BEGIN_SRC emacs-lisp

;; When opening a file start at home directory
(setq default-directory "~/")

;; Allow 20MB of memory before calling GC
(setq gc-cons-threshold 20000000)

;; Call delete-trailing-whitespace every time a buffer is saved
(add-hook 'before-save-hook 'delete-trailing-whitespace)

;; Treat camel-case as separate words
(add-hook 'prog-mode-hook 'subword-mode)

;; When opening a file, always follow symlinks
(setq vc-follow-symlinks t)

;; When saving a file that starts with '#!', make it executable
(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)

;; Single space after periods
(setq sentence-end-double-space nil)

;; Offer to create directories on save
(add-hook 'before-save-hook
  (lambda ()
    (when buffer-file-name
      (let ((dir (file-name-directory buffer-file-name)))
        (when (and (not (file-exists-p dir))
                        (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
          (make-directory dir t))))))

;; Apply changes to highlighted region
(transient-mark-mode t)

;; Delete selected text when I start typing
(delete-selection-mode t)

;; Ensure that files end with newline
(setq require-final-newline t)

;; Don't present the usual startup message and clear the scratch buffer
(setq inhibit-startup-message t)
(setq initial-scratch-message nil)

;; Make dired file sizes human readable
(setq-default dired-listing-switches "-alh")

;; "y/n" instead of "yes/no"
(fset 'yes-or-no-p 'y-or-n-p)

;; Don't ask me which buffer to kill, just kill 'this' buffer
(global-set-key (kbd "C-x k") 'kill-this-buffer)

;; Switch to other window with C-o instead of C-x o
;; I find the old C-o keybinding (delete blank line) confusing and normally
;; delete a line with C-a C-k or C-S-backspace
(global-set-key (kbd "C-o") 'other-window)

;; Enable syntax highlighting whenever possible
(global-font-lock-mode t)

;; Refresh buffers when files change
(global-auto-revert-mode t)

;; Show matching parens
(show-paren-mode t)
(setq show-paren-delay 0.0)

;; Set default linelength
(setq-default fill-column 80)

;; Show column number
(column-number-mode 1)

;; When double clicking on a file in finder open it as a buffer in the
;; existing emacs frame, rather than creating a new frame just for that file
(setq ns-pop-up-frames nil)

;; Yank text where point is, not where mouse cursor is
(setq mouse-yank-at-point t)


(defun backup-to-temp-directory ()
  "Store backups and auto-saved files in
  TEMPORARY-FILE-DIRECTORY (which defaults to /tmp on Unix),
  instead of in the same directory as the file. This means we're
  still making backups, but not where they'll get in the way.
  WARNING: on most Unix-like systems /tmp is volatile, in-memory
  storage, so your backups won't survive if your computer crashes!
  If you're not willing to take this risk, you shouldn't enable
  this setting."
  (setq backup-directory-alist
    `((".*" . ,temporary-file-directory)))
  (setq auto-save-file-name-transforms
    `((".*" ,temporary-file-directory t))))
#+END_SRC

** Recent Files

Build a list of recently used files, easily accessible via the "C-x C-r" keybinding.

#+begin_src emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 32)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+end_src

** Desktop Save Mode

Most of the times it's convenient that emacs opens previously opened files
when starting up (unless specified files are given as startup arguments).
=desktop-save-mode= does the trick.

#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
#+END_SRC

To start emacs without opening last session's files, start it by =emacs --no-desktop=

** Buffers

Give me some help when switching buffers with =C-x b=:

#+BEGIN_SRC emacs-lisp
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
(ido-mode 1)
#+END_SRC

Also activate window switching with =S-<left>=, =S-<right>=, =S-<up>= and
=S-<down>= :

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)
#+END_SRC

Unfortunately this doesn't work nicely with .org files. Therefore, in the org
config, I'm replacing disputed keys.

** Folding

I found a couple of nice things when searching for code folding opportunities:
outline-mode, hide-show, folding-mode and M-x occur among others. But what seems
to work easiest and most robust for me is 'set-selective-display'. This is a
standard function that accepts an optional numerical argument. With the argument
you tell it to 'fold' lines with indent >= argument. I decided to bind it to a
key and toggle between indent 1 and indent 0 which seems to fit 90% of my use
cases:

#+BEGIN_SRC emacs-lisp
(defun mmz/toggle-selective-display (column)
  (interactive "P")
  (set-selective-display
   (if selective-display nil (or column 1))))

(global-set-key (kbd "<f12>") 'mmz/toggle-selective-display)
#+END_SRC

** SQL-mode

When using =M-x sql-postgres= , ask for user, password, server, database and
port. Use these defaults:

#+BEGIN_SRC emacs-lisp
(setq sql-postgres-login-params
      '((user     :default "lms-client")
         password
        (database :default "lms")
        (server   :default "localhost")
        (port     :default 5432)))
#+END_SRC

Furthermore, truncate long lines (needed when rows have lots of data in them).

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (toggle-truncate-lines t)))
#+END_SRC

** Imenu: jump to definitions

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-i") 'imenu)
#+END_SRC

** Spelling - Enable / Disable flyspell mode

#+BEGIN_SRC emacs-lisp
(dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
  (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

* Org-mode
** Display preferences

Pretty bullets instead of asterisks.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
 :ensure t
 :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

Nice arrow instead of the usual ellipsis (=...=) when stuff is folded.

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⤵")
#+END_SRC

** Keybindings

#+begin_src emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-iswitchb)
#+end_src

Don't override the windmove keybindings (=S-<left> <right> <up> & <down>=).

#+BEGIN_SRC emacs-lisp
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

** Agenda files

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files
  '("~/Dropbox/org/pathis.org"
    "~/Dropbox/org/department.org"
    "~/Dropbox/org/leisure.org"))
#+END_SRC

** Drawers, logging and clocking

Let's not clutter up our tasks:

#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer   "LOGBOOK")
(setq org-clock-into-drawer "CLOCK")
#+END_SRC

I don't want to resolve clocks, but simply clock in and clock out when I run the
commands:

#+BEGIN_SRC emacs-lisp
(setq org-clock-idle-time             nil)
(setq org-clock-continuously          nil)
(setq org-clock-persist               nil)
(setq org-clock-in-resume             nil)
(setq org-clock-auto-clock-resolution nil)

(org-clock-persistence-insinuate)
#+END_SRC

Logbook logging:

| Keybinding | Description       |
|------------+-------------------|
| C-c C-z    | Take a Quick note |
| C-c C-c    | Store note        |
|------------+-------------------|

Clocking (time tracking):

| Keybinding      | Description           |
|-----------------+-----------------------|
| C-c C-x C-i     | clock in              |
| C-c C-x C-o     | clock out             |
| C-c C-x C-d     | show times            |
| C-c C-x C-q     | Cancel clock          |
| C-c C-x C-x     | Restart clock         |
| C-u C-c C-x C-x | Restart with menu     |
| C-c C-x C-j     | jump to clocked tasks |
|-----------------+-----------------------|

** Capture

#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file "~/Dropbox/org/capture.org")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
  '(("e" "Explore"
     entry
     (file+headline org-default-notes-file "Explore")
     "* %?\n")

    ("i" "Idea"
     entry
     (file+headline org-default-notes-file "Ideas")
     "* %?\n")

    ("l" "Listen"
     entry
     (file+headline org-default-notes-file "Listen")
     "* %?\n")

    ("q" "Quote"
     entry
     (file+headline org-default-notes-file "Quotes")
     "* %^{Quote} - %^{Author} (source: %^{Source})")

    ("r" "Read"
     entry
     (file+headline org-default-notes-file "Read")
     "* %?\n")

    ("t" "Todo"
     entry
     (file+headline org-default-notes-file "Tasks")
     "* TODO %?\n")

    ("w" "Watch"
     entry
     (file+headline org-default-notes-file "Watch")
     "* %?\n")))
#+END_SRC

Use ido for completion

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-outline-path t)
(setq org-outline-path-complete-in-steps nil)
#+END_SRC

** Code blocks

Syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

Allow =babel= to evaluate Emacs lisp:

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
  'org-babel-load-languages
    '((emacs-lisp . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

** To-do items

My todo workflow:

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
;;'((sequence "TODO(t)" "BUSY(b!)" "WAIT(w@/!)" "|" "DONE(d!)" "CANCELLED(c@/!)")))
;;'((sequence "TODO(t)" "BUSY(b!)" "WAIT(w!)" "|" "DONE(d!)" "CANCELLED(c!)")))
  '((sequence "TODO(t)" "BUSY(b)" "PENDING(p)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC

The items before the pipe ="|"= need action while the items behind it need no
further action. The special characters are:

- =<char>= for fast access key definition (prompted for after =C-c C-t=)
- =!= for adding a timestamp
- =@= for prompting for a note

=-edit-=

I found out that I want to be able to cycle quickly through my items
=(S-<arrow>)= and only add notes when needed. Therefore, I commented my earlier
todo-keyword definition, but leave it here in case I want to activate them
again.

Checkboxes are not included in the global TODO list and can be used to split a
todo item into a number of simpler tasks:

- [X] plan workflow
- [-] implement workflow
  - [X] add workflow
  - [X] explain workflow
  - [ ] test workflow

** Tags

Tags workflow:

- Add header to the top of a file containing tags and optionally shortcuts:

#+TAGS: IMPORTANT(i) URGENT(u)

- =C-c C-c= to evaluate a newly created tagline
- =C-c C-q= to add a tag to an org-mode header item. Here you can use the
  defined shortcuts. You can add multiple tags on a header item. Nested items
  will inherit the tags added to its parent.
- =C-c / m= for finding matching tags (=C-c a m when you're in an agenda file).
  You can combine tag searches, so for instance search for: IMPORTANT, URGENT,
  IMPORTANT|URGENT or IMPORTANT&URGENT . Results will be highlighted in your
  buffer.
- Edit text or =C-c C-c= to remove highlights.

** Newlines allowed inside marked up expression

Default, =org-mode= only allows markup to span a single newline. I often feel
the need to span a whole paragraph, so I'm increasing this var here to what I
think will be pretty much the max number of consecutive lines I ever want to
mark up.

#+BEGIN_SRC emacs-lisp
(setcar (nthcdr 4 org-emphasis-regexp-components) 128)
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

More info [[https://emacs.stackexchange.com/questions/13820/inline-verbatim-and-code-with-quotes-in-org-mode][in this stackoverflow answer]] .

* Packages

This configuration uses the [[https://github.com/jwiegley/use-package][use-package]] package from John Wiegley. [[https://www.lunaryorn.com/posts/my-emacs-configuration-with-use-package.html][This blog]]
nicely explains some of the features.

** Smex

Smex adds history and suggestions to M-x

#+begin_src emacs-lisp
(use-package smex
  :ensure t
  :bind (("M-x"         . smex)
         ("M-X"         . smex-major-mode-commands)
         ("C-c C-c M-x" . execute-extended-command)))
#+end_src

Main Usage:

| Keybinding  | Description                                       |
|-------------+---------------------------------------------------|
| M-x         | Same as old M-x but with history & suggestions    |
| M-X         | Only show commands relevant to current major mode |
| C-c C-c M-x | Link to old M-x command                           |
|-------------+---------------------------------------------------|
| C-h w       | 'Where is' - shows kbd for selected command       |
| C-h f       | Runs 'describe Function' on selected command      |
| M-.         | Jumps to definition of selected command           |
|-------------+---------------------------------------------------|

Links:

- [[https://github.com/nonsequitur/smex][Smex on github (nonsequitur)]]

** Neotree

Neotree shows your directories and files in a tree view.

#+begin_src emacs-lisp
(use-package neotree
  :ensure t
  :bind (("<f8>" . neotree-toggle)))
#+end_src

Main Usage:

| Keybinding | Description                      |
|------------+----------------------------------|
| f8         | Toggle neotree                   |
|------------+----------------------------------|
| g          | Refresh neotree                  |
| H          | Toggle display hidden files      |
|------------+----------------------------------|
| C-c C-n    | Create a new file or directory   |
| C-c C-d    | Delete a file or directory       |
| C-c C-r    | Rename a file or directory       |
| C-c C-c    | Change root directory to display |
|------------+----------------------------------|

Links:

- [[https://github.com/jaypei/emacs-neotree][Neotree on Github (jaypei)]]
- [[https://www.emacswiki.org/emacs/NeoTree][Neotree on emacswiki]]

** Engine-Mode

Engine-mode allows me to do internet searches on configured search engines.

#+BEGIN_SRC emacs-lisp
(use-package engine-mode
  :ensure t)

;; enable engine-mode globally
(engine-mode t)

(defengine amazon
  "https://www.amazon.com/s/ref=nb_sb_noss?field-keywords=%s"
  :keybinding "a")

(defengine clojure-docs
  "https://clojuredocs.org/search?q=%s"
  :keybinding "c")

(defengine dictionary
  "http://www.dictionary.com/browse/%s"
  :keybinding "d")

(defengine google
  "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
  :keybinding "g")

(defengine github
  "https://github.com/search?ref=simplesearch&q=%s"
  :keybinding "h")

(defengine google-images
  "http://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
  :keybinding "i")

(defengine google-maps
  "http://maps.google.com/maps?q=%s"
  :keybinding "m")

(defengine qwant
  "https://www.qwant.com/?q=%s"
  :keybinding "q")

(defengine stack-overflow
  "https://stackoverflow.com/search?q=%s"
  :keybinding "s")

(defengine google-translate
  "https://translate.google.com/#auto/en/%s"
  :keybinding "t")

(defengine wikipedia
  "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
  :keybinding "w")

(defengine youtube
  "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
  :keybinding "y")
#+END_SRC

Main usage:

=C-x / <key for your engine here>= for invoking engine-mode

If your cursor is on a word when invoking engine-mode, that word will
be the default search value unless you overwrite it by typing another
search term.

If you have selected a piece of text (C-SPC ...) and invoke
engine-mode, that piece of text will be your search string.

So for instance I want to search for "emil ernebro" on youtube:

- =C-x / y=
- type "emil ernebro"
- engine-mode will open youtube and search for emil ernebro

Other way to search for "emil ernebro", this time on google-images:

- Select "emil ernebro" in the current textbuffer
- =C-x / i=

Links:

- [[https://github.com/hrs/engine-mode][engine-mode on github (hrs)]]
- [[https://www.youtube.com/watch?v%3DMBhJBMYfWUo][hrs on youtube with short video on engine-mode]]

** Magit

Magit is a brilliant interface to git. It provides several 'popups' (like
commit, push, log, diff) which guide you through the (git) options.

#+begin_src emacs-lisp
(use-package magit
  :ensure t
  :bind (("C-c g" . magit-status)))
#+end_src

Main Usage:

| Keybinding | Description                         |
|------------+-------------------------------------|
| C-c g      | (ma)git status                      |
|------------+-------------------------------------|
| h          | list all popups + commands          |
| g          | Refresh                             |
| n          | Next section                        |
| p          | Previous section                    |
| TAB        | expand or collapse section at point |
|------------+-------------------------------------|
| s          | stage                               |
| u          | unstage                             |
| c          | commit popup                        |
| C-c C-c    | really commit                       |
| P          | push popup                          |
| u          | push to upstream                    |
|------------+-------------------------------------|

** Rest-Client

I'm using Restclient to test REST calls from text files.
Additional info on [[https://github.com/pashky/restclient.el][github]] (including examples)

#+begin_src emacs-lisp
(use-package restclient
  :ensure t)
#+end_src

Main Usage:

| Keybinding | Description                                      |
|------------+--------------------------------------------------|
| C-c C-c    | runs query under cursor, switch to result window |
| C-c C-v    | runs query under cursor, stays in current window |
| C-c C-p    | jump to previous query                           |
| C-c C-n    | jump to next query                               |
| C-c C-.    | mark the query under the cursor                  |
| C-c C-u    | copy query under the cursor as curl cmd          |
|------------+--------------------------------------------------|

** Markdown

Use markdown mode, also for my foldingtext files

#+begin_src emacs-lisp
(use-package markdown-mode
  :ensure   t
  :commands (markdown-mode gfm-mode)
  :mode     (("README\\.md\\'" . gfm-mode)
             ("\\.md\\'"       . markdown-mode)
             ("\\.markdown\\'" . markdown-mode)
             ("\\.ft\\'"       . markdown-mode))
  :init     (setq markdown-command "multimarkdown"))
#+end_src

** Winner mode

winner-mode lets you use =C-c <left>= and =C-c <right>= to switch between window
configurations. This is handy when something has popped up a buffer that you
want to look at briefly before returning to whatever you were working on. When
you’re done, press =C-c <left>=. [[https://www.youtube.com/watch?v%3DT_voB16QxW0][See winner-mode in action.]]

#+BEGIN_SRC emacs-lisp
(use-package winner
  :ensure t
  :config (winner-mode 1))
#+END_SRC

** Undo-tree

People often struggle with the Emacs undo model, where there’s really no concept
of “redo” - you simply undo the undo. This package lets you use =C-x u=
(undo-tree-visualize) to visually walk through the changes you’ve made, undo
back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree
  :ensure t
  :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC

** Company

Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

Main usage:

| keybinding | description                                   |
|------------+-----------------------------------------------|
| <f1>       | Display documentation for selected completion |
| C-w        | Where is? - See source of selected completion |
|------------+-----------------------------------------------|

In addition:

To see a list of enabled backends: =M-x customize-variable RET company-backends=

#+BEGIN_SRC emacs-lisp
(use-package company
  :ensure t
  :config (global-company-mode))
#+END_SRC

** Parentheses!

If parentheses are used, enable paredit and highlight and color them all!

#+BEGIN_SRC emacs-lisp
;; Paredit
(use-package paredit
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook                  #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook                        #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook                        #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook            #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook                      #'enable-paredit-mode)
  (add-hook 'clojure-mode-hook                     #'enable-paredit-mode))


;; Ensure paredit is used EVERYWHERE!
(use-package paredit-everywhere
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'paredit-everywhere-mode))

(use-package highlight-parentheses
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook
            (lambda()
              (highlight-parentheses-mode))))

(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'lisp-mode-hook
            (lambda()
              (rainbow-delimiters-mode))))

(global-highlight-parentheses-mode)
#+END_SRC

Main usage:

| Keybinding | Description          | Example                |
|------------+----------------------+------------------------|
| C-M-f      | Move cursor forward  |                        |
| C-M-b      | Move cursor backward |                        |
|------------+----------------------+------------------------|
| C-right    | Forward  slurp       | (1 2) 3 -> (1 2 3)     |
| C-left     | Forward  barf        | (1 2 3) -> (1 2) 3     |
| C-M-right  | Backward barf        | (1 2 3) -> 1 (2 3)     |
| C-M-left   | Backward slurp       | 1 (2 3) -> (1 2 3)     |
|------------+----------------------+------------------------|
| C-k        | Kill until next )    | (1 (_2) 3) -> (1 () 3) |
|------------+----------------------+------------------------|
| M-(        | Wrap around          | (1 2 3) -> (1 (2) 3)   |
| M-s        | Splice               | (1 (2) 3) -> (1 2 3)   |
| M-S        | Split                | (1 2) -> (1) (2)       |
| M-J        | Join                 | (1) (2) -> (1 2)       |
|------------+----------------------+------------------------|

Conceptually, when barfing and slurping, you're moving the =)= in the direction
of the arrow.

Additionally, I had to change the keybindings of my magnet app because they made
heavy use of =C-M= combinations and clashed with the paredit bindings.

** Yasnippet

#+BEGIN_SRC emacs-lisp
(use-package yasnippet
  :ensure t
  :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
    (yas-global-mode 1))
#+END_SRC

I didn't download any preconfigured snippets and decided to create them
manually when needed. Snippet inspiration can be found [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master/snippets][here]].

Main Usage:

| Function               | Additional info                             |
|------------------------+---------------------------------------------|
| yas-new-snippet        | C-c C-c to save                             |
| yas-visit-snippet-file | opens snippets definition file              |
|------------------------+---------------------------------------------|
| snippet-mode           | to edit snippets (with syntax highlighting) |
| yas-tryout-snippet     | (in snippet-mode)                           |
|------------------------+---------------------------------------------|

Additional information on [[https://joaotavora.github.io/yasnippet/snippet-development.html][writing snippets]].

** Cider

CIDER is the *C*lojure(Script) *I*nteractive *D*evelopment *E*nvironment that
*R*ocks! [[http://cider.readthedocs.io/en/latest/running_tests/][Read The Docs.]]

#+BEGIN_SRC emacs-lisp
(use-package cider
  :ensure t
  :pin melpa-stable
  :config
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'paredit-mode)
    (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-mode-hook      #'company-mode)
    (add-hook 'cider-mode-hook      #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook      #'eldoc-mode)
    (add-hook 'cider-mode-hook      #'paredit-mode)
    (add-hook 'cider-mode-hook      #'rainbow-delimiters-mode)
    (setq cider-repl-use-pretty-printing t)
;;  (setq nrepl-log-messages t) ;; for debugging / inspecting cider
    (setq cider-test-show-report-on-success t))
#+END_SRC

The config basically configures:

- use (fuzzy) completion in cider modes (also repl)
- use paredit while in clojure mode
- use eldoc in repl mode (displays function signatures in the minibuffer while
  typing)
- Pretty Print when possible
- Log communication with the nREPL server (will create buffers like
  =*nrepl-messages conn-name*=) ->

Main usage:

Open a file belonging to your =lein= or =boot= project (like =core.clj=) and
call the =cider-jack-in= function (=M-x cider-jack-in RET=). This will start an
nREPL server with all the project dependencies loaded in and CIDER will
automatically connect to it.

Alternatively you can use =C-u M-x cider-jack-in RET= to specify the name of a
lein or boot project, without having to visit any file in it. This option is
also useful if your project contains both project.clj and build.boot and you
want to launch a repl for one or the other.

In Clojure(Script) buffers the command cider-jack-in is bound to =C-c M-j=.

Cider Repl & Source Buffer:

| keybinding  | description                                                       |
|-------------+-------------------------------------------------------------------|
| C-c C-d C-a | Apropos- Search (loaded) functions                                |
| C-c C-d C-d | With cursor on function, show documentation.                      |
| C-c C-d C-r | With cursor on function, show grimoire docs (including examples!) |
| M-.         | View source, (M-, to go back again)                               |
| C-c C-z     | Switch to source buffer                                           |
| C-u C-c C-z | Switch to repl and sync namespace with source buffer              |
|             |                                                                   |
|-------------+-------------------------------------------------------------------|

Cider Source Buffer:

| keybinding             | description               | example                                   |
|------------------------+---------------------------+-------------------------------------------|
| C-c C-k                | Load this buffer          |                                           |
| C-c C-e                | Evaluate last sexpression | (inc (+ 2 3)_) -> 5 ; (inc (+ 2 3))_ -> 6 |
| C-c C-c                | Evaluate top level form   | (inc (+ 2 _ 3)) -> 6                      |
|------------------------+---------------------------+-------------------------------------------|
| C-c M-i                | Inspect a value           |                                           |
| C-c M-t v              | Toggle var tracing        |                                           |
| C-c M-t n              | Toggle ns tracing         |                                           |
| C-u C-M-x              | Debug top-level form      |                                           |
| M-x cider-inspect-expr | inspect given expression  |                                           |
|------------------------+---------------------------+-------------------------------------------|
| C-c C-t n              | Run tests in ns           |                                           |
| C-c C-t p              | Run tests in project      |                                           |
|------------------------+---------------------------+-------------------------------------------|

Cider-doc:

| keybinding | description      |
|------------+------------------|
| s          | show source code |
|------------+------------------|


Flows:

- Working in cider repl, cursor on function -> =C-c C-d d= to show documentation
  of function -> =s= to view source -> =M-,= to return to doc view
- Working in cider repl, cursor on function -> =M-.= to show source -> =M-,= to
  go back to repl again.
- Switching between repl and source buffer: =C-c C-z=

Also supercool: =cider-enlighten= to show all intermediate values of a called
function in the source buffer.

** Which-Key

Displays the key bindings following your currently entered incomplete command (a
prefix) in a popup.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :ensure t
  :config
    (which-key-setup-side-window-right-bottom)
    (which-key-mode))
#+END_SRC

=side-window-right-bottom= tries to show key options on the right side of the
screen, but will switch to the bottom if there's not enough space on the right.
=which-key-mode= enables the which-key minor mode.

** Avy

Avy helps jumping through *visible* text.

#+BEGIN_SRC emacs-lisp
(define-prefix-command 'f9-map)

(use-package avy
  :ensure t
  :bind   (("<f9>"   . f9-map)
           ("<f9> c" . avy-goto-char)
           ("<f9> 2" . avy-goto-char-2)
           ("<f9> t" . avy-goto-char-timer)
           ("<f9> l" . avy-goto-line)
           ("<f9> w" . avy-goto-word-1)
           ("<f9> o" . avy-org-goto-heading-timer))
  :config (setq avy-background t))
#+END_SRC

** Fireplace

MUST HAVE emacs functionality:

#+BEGIN_SRC emacs-lisp
(use-package fireplace
  :ensure t)
#+END_SRC

- =M-x fireplace= to engage in deep thinking
- =M-x fireplace-off= or =q= to put the fire out

** Expand Region

Expands regions in a =dwim= way.

#+BEGIN_SRC emacs-lisp
(use-package expand-region
  :ensure t
  :bind ("C-@" . er/expand-region))
#+END_SRC

Github repo can be found [[https://github.com/magnars/expand-region.el][here]].

** Web mode

Web mode makes sure you can work with HTML, JavaScript and CSS in one and the
same HTML file.

#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :ensure t
  :mode "\\.html?\\'"
  :config
  (progn
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-enable-current-element-highlight t)
    (setq web-mode-enable-css-colorization t)
    (setq web-mode-enable-auto-pairing t)))
#+END_SRC

** Emmet mode

Powerful way of creating HTML & CSS snippets.

#+BEGIN_SRC emacs-lisp
(use-package emmet-mode
  :ensure t
  :commands emmet-mode
  :config
  (add-hook 'web-mode-hook  'emmet-mode)
  (add-hook 'html-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook  'emmet-mode))
#+END_SRC

- =C-j= is the important keybinding here
- See [[https://emmet.io/][emmet site]] for more info

Some examples:

- =a:link= =C-j= expands to:

#+BEGIN_SRC html
<a href="http://"></a>
#+END_SRC

- =nav>ul>li= =C-j= expands to:

#+BEGIN_SRC html
<nav>
  <ul>
    <li></li>
  </ul>
</nav>
#+END_SRC

-  =.item{$}*3= =C-j= expands to:

#+BEGIN_SRC html
<div class="item">1</div>
<div class="item">2</div>
<div class="item">3</div>
#+END_SRC

- =.container>p*3>lorem5= expands to:

#+BEGIN_SRC html
<div class="container">
  <p>
    Ante metus, dictum at tempor?
  </p>
  <p>
    Feugiat in ante metus, dictum.
  </p>
  <p>
    Semper auctor neque, vitae tempus!
  </p>
</div>
#+END_SRC

More to be found in the [[https://docs.emmet.io/cheatsheet-a5.pdf][huge cheatsheet (pdf)]].

* Debugging

Sometimes adding a package doesn't work as expected. In those cases you can try
several things:

- Try starting emacs from the terminal with ~emacs --debug-init~
- Set ~use-package-verbose~ to ~t~ . Errors occuring while initializing or
  configuring a package will not stop emacs from loading. With this setting the
  errors will be reported to a special ~*Warnings*~ popup buffer so you can debug
  the package loading.
- Try ~package-refresh-contents~ or check if the troublesome package is in
  ~package-list-packages~
* Try?

- [[https://github.com/zenozeng/yafolding.el][yafolding]]? ... Problem with current indent based folding is that it doesn't
  fold comments (see folding header). So new solution should fix that.

* Cleanup?

- Avy; I don't use it that often. For the visible area it might be just as easy
  to =C-9 C-n= or =C-9 C-p= repeatedly and =C-arrow= to the word you're moving
  to. Or when you're already on the correct line, =C-a= to move to the begin,
  =C-e= to move to the end and =C-44 C-f= to move approximately halfway if
  you're on the beginning of the line. Other option is to simply =C-s= or =C-r=;
  The way it works seems to break my flow; first =<f12> t= then some typing and
  then selecting a character randomly assigned by avy... Somehow that requires
  too much conscious effort. The only reason I'm not deleting it immediately is
  that I want to give it a real chance because when it works, it works like
  magic.
