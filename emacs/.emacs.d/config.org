#+TITLE: Emacs Configuration
#+AUTHOR: M.Metz

* Setup

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start of Emacs Config")
#+END_SRC

This is needed, because (I think) flycheck started complaining that the 'cl
library is deprecated. That complaining stopped by adding this dependency.

#+BEGIN_SRC emacs-lisp
(require 'cl-lib)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun disable-fylcheck-in-org-src-block ()
  (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))

(add-hook 'org-src-mode-hook 'disable-fylcheck-in-org-src-block)
#+END_SRC

* Introduction

The emacs-lisp code in this file will run when emacs starts. A great use case
for [[https://en.wikipedia.org/wiki/Literate_programming]['literate programming']] imho.

Mostly inspired by / copied from:

- [[https://github.com/hrs/dotfiles][hrs]]
- [[https://github.com/sachac/.emacs.d/blob/gh-pages/Sacha.org][sachac]]
- [[https://github.com/danielmai/.emacs.d/blob/master/config.org][danielmai]]

with a bunch of personal extensions and flavors.

* Installing Emacs

On macOS, I use [[http://brew.sh/][homebrew]] to install emacs.

#+begin_src sh
brew cask install emacs
#+end_src

#+BEGIN_SRC sh
brew install aspell
#+END_SRC

- aspell is needed for spell checking

* Upgrading Emacs

Since I'm using homebrew I can simply run ~brew update~ and then ~brew upgrade
emacs~. After upgrade, it's wise to debug the emacs setup, see [[Debugging][Debugging]]. If
your setup is ruined beyond repair, you can link your environment back to the
old brew installation (using brew). That way, you can wait for a more stable
release while continuing to work in your old setup.

My experience going from emacs 25.3 to 26.1 and from 26.1 to 26.3 was that
nothing was broken and nothing needed to be fixed. I could simple continue my
work.

Another option I have been thinking about is using a (major) emacs upgrade as an
'excuse' to clean up my emacs config. Simply start with a clean emacs install
and a clean config and only add those packages you really need or really miss.
That'll keep the config clean over time and keeps the emacs config skills
trained.

* Override Defaults
** UI
*** (No) Menu & (no) scroll bar

I have never felt the need to use the menu or the scroll bar in emacs.

#+begin_src emacs-lisp
(tool-bar-mode 0)
(menu-bar-mode 0)
(when window-system
  (scroll-bar-mode -1))
(setq scroll-conservatively 100)
#+end_src

The 'scroll-conservatively' makes sure emacs doesn't recenter the cursor after
scrolling.

*** Window Size

I like this as a default size for my emacs app window:

#+begin_src emacs-lisp
(when window-system
  (set-frame-size (selected-frame) 112 56))
#+end_src

Keybindings to resize windows within emacs app window:

#+begin_src emacs-lisp
(bind-key "C-c C-<left>"  'shrink-window-horizontally)
(bind-key "C-c C-<right>" 'enlarge-window-horizontally)
(bind-key "C-c C-<down>"  'shrink-window)
(bind-key "C-c C-<up>"    'enlarge-window)
#+end_src

Unfortunately, the order of the '(no) menu & (no) scroll bar' paragraph and the
'window size' paragraph is important. If you change the order (window size
first), the window size will be the standard emacs window size, not the
specified size.

In addition, since I've activated 'save-desktop', emacs will remember the
settings of my last session. Therefore, this windowsize will only be used when
starting emacs from the terminal with the =--no-desktop= switch.

*** Font Size and Resizing

Resize text in every buffer and also in modeline. Also increases app window.
Default zoom bindings still work (=C-x C-+= etc.)

#+BEGIN_SRC emacs-lisp
(setq mmz/default-font "Menlo")
(setq mmz/default-font-size 14)
(setq mmz/current-font-size mmz/default-font-size)

(setq mmz/font-change-increment 1.1)

(defun mmz/font-code ()
  "Return a string representing the current font (like \"Menlo-14\")."
  (concat mmz/default-font "-" (number-to-string mmz/current-font-size)))

(defun mmz/set-font-size ()
  "Set the font to `mmz/default-font' at `mmz/current-font-size'.
   Set that for the current frame, and also make it the default for
   other, future frames."
  (let ((font-code (mmz/font-code)))
    (add-to-list 'default-frame-alist (cons 'font font-code))
    (set-frame-font font-code)))

(defun mmz/reset-font-size ()
  "Change font size back to `mmz/default-font-size'."
  (interactive)
  (setq mmz/current-font-size mmz/default-font-size)
  (mmz/set-font-size))

(defun mmz/increase-font-size ()
  "Increase current font size by a factor of `mmz/font-change-increment'."
  (interactive)
  (setq mmz/current-font-size
        (ceiling (* mmz/current-font-size mmz/font-change-increment)))
  (mmz/set-font-size))

(defun mmz/decrease-font-size ()
  "Decrease current font size by a factor of `mmz/font-change-increment', down to a minimum size of 1."
  (interactive)
  (setq mmz/current-font-size
        (max 1
             (floor (/ mmz/current-font-size mmz/font-change-increment))))
  (mmz/set-font-size))

(define-key global-map (kbd "C-)") 'mmz/reset-font-size)
(define-key global-map (kbd "C-+") 'mmz/increase-font-size)
(define-key global-map (kbd "C-=") 'mmz/increase-font-size)
(define-key global-map (kbd "C-_") 'mmz/decrease-font-size)
(define-key global-map (kbd "C--") 'mmz/decrease-font-size)

(mmz/reset-font-size)
#+END_SRC

*** Highlight current line

Softly highlight the current line:

#+begin_src emacs-lisp
(when window-system
  (global-hl-line-mode))
#+end_src

*** Disable annoying (visible) bells

[[http://stackoverflow.com/questions/11679700/emacs-disable-beep-when-trying-to-move-beyond-the-end-of-the-document][Disable Annoying Alarms]]

#+begin_src emacs-lisp
(defun my-bell-function ())
(setq ring-bell-function 'my-bell-function)
(setq visible-bell nil)
#+end_src

*** Wrap paragraphs automatically

AutoFillMode automatically wraps paragraphs. If you prefer to do it manually
disable this code and hit =M-q= with the cursor in the paragraph you want to
wrap.

Toggles wrapping with =C-c q=

#+begin_src emacs-lisp
(add-hook 'text-mode-hook 'turn-on-auto-fill)
(add-hook 'gfm-mode-hook 'turn-on-auto-fill)
(add-hook 'org-mode-hook 'turn-on-auto-fill)

(global-set-key (kbd "C-c q") 'auto-fill-mode)
#+end_src

*** Themes

The [[https://github.com/bbatsov/solarized-emacs/][bbatsov solarized theme]] is quite easy on the eyes. However, I like the
default emacs theme. Therefore, I only load solarized when needed / wanted
with =M-x load-theme= (If I want solarized-dark as default, I'll have to add
=(load-theme 'solarized-dark t)= to this config)

Since I'm saving my desktop when closing emacs, an applied theme will also be
loaded when restarting emacs. To be able to 'reload' the default theme, I've
started =emacs --no-desktop=, started the theme editor with =M-x
customize-create-theme= and saved that theme as 'default'.

So after applying another theme, I can now always return to my default theme by
=M-x load-theme default=.

In case of emergency: =(mapcar #'disable-theme custom-enabled-themes)= and start
all over.

#+begin_src emacs-lisp
(use-package solarized-theme
  :defer 10
  :init
  (setq solarized-use-variable-pitch  nil)
  (setq solarized-scale-org-headlines nil)
  :ensure t)
#+end_src

*** Fancy Lambda's

Eye candy:

#+BEGIN_SRC emacs-lisp
(global-prettify-symbols-mode t)
#+END_SRC

** Sensible defaults

I use most of [[https://github.com/hrs/sensible-defaults.el][sensible defaults]] for basic settings, but I decided to inline
it into this file, to reduce the *magic*.

#+BEGIN_SRC emacs-lisp

  ;; When opening a file start at home directory
  (setq default-directory "~/")

  ;; Allow 20MB of memory before calling GC
  (setq gc-cons-threshold 20000000)

  ;; Call delete-trailing-whitespace every time a buffer is saved
  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  ;; Treat camel-case as separate words
  (add-hook 'prog-mode-hook 'subword-mode)

  ;; When opening a file, always follow symlinks
  (setq vc-follow-symlinks t)

  ;; When saving a file that starts with '#!', make it executable
  (add-hook 'after-save-hook
	    'executable-make-buffer-file-executable-if-script-p)

  ;; Single space after periods
  (setq sentence-end-double-space nil)

  ;; Offer to create directories on save
  (add-hook 'before-save-hook
    (lambda ()
      (when buffer-file-name
	(let ((dir (file-name-directory buffer-file-name)))
	  (when (and (not (file-exists-p dir))
			  (y-or-n-p (format "Directory %s does not exist. Create it?" dir)))
	    (make-directory dir t))))))

  ;; Apply changes to highlighted region
  (transient-mark-mode t)

  ;; Delete selected text when I start typing
  (delete-selection-mode t)

  ;; Ensure that files end with newline
  (setq require-final-newline t)

  ;; Don't present the usual startup message and clear the scratch buffer
  (setq inhibit-startup-message t)
  (setq initial-scratch-message nil)

  ;; Make dired file sizes human readable
  (setq-default dired-listing-switches "-alh")

  ;; "y/n" instead of "yes/no"
  (fset 'yes-or-no-p 'y-or-n-p)

  ;; Don't ask me which buffer to kill, just kill 'this' buffer
  (global-set-key (kbd "C-x k") 'kill-this-buffer)

  ;; Switch to other window with C-o instead of C-x o
  ;; I find the old C-o keybinding (delete blank line) confusing and normally
  ;; delete a line with C-a C-k or C-S-backspace
  (global-set-key (kbd "C-o") 'other-window)

  ;; Enable syntax highlighting whenever possible
  (global-font-lock-mode t)

  ;; Refresh buffers when files change
  (global-auto-revert-mode t)

  ;; Show matching parens
  (show-paren-mode t)
  (setq show-paren-delay 0.0)

  ;; Set default linelength
  (setq-default fill-column 80)

  ;; Show column number
  (column-number-mode 1)

  ;; When double clicking on a file in finder open it as a buffer in the
  ;; existing emacs frame, rather than creating a new frame just for that file
  (setq ns-pop-up-frames nil)

  ;; Yank text where point is, not where mouse cursor is
  (setq mouse-yank-at-point t)

  ;; Don't clutter my working directories with backup files

  (setq version-control     t   ;; Use version numbers for backup
        kept-new-versions   8   ;; Number of newest versions to keep
        kept-old-versions   0   ;; Number of oldest versions to keep
        delete-old-versions t   ;; Don't ask to delete excess backup versions
        backup-by-copying   t)  ;; Copy all files, don't rename them

  ;; Default and per-save backups go here:
  (setq backup-directory-alist '(("" . "~/.emacs-backup/per-save")))

  ;; https://stackoverflow.com/a/20824625

  (defun force-backup-of-buffer ()
    ;; Make a special "per session" backup at the first save of each
    ;; emacs session.
    (when (not buffer-backed-up)
      ;; Override the default parameters for per-session backups.
      (let ((backup-directory-alist '(("" . "~/.emacs-backup/per-session")))
            (kept-new-versions 3))
        (backup-buffer)))
    ;; Make a "per save" backup on each save.  The first save results in
    ;; both a per-session and a per-save backup, to keep the numbering
    ;; of per-save backups consistent.
    (let ((buffer-backed-up nil))
      (backup-buffer)))

  (add-hook 'before-save-hook  'force-backup-of-buffer)

#+END_SRC

** Recent Files

Build a list of recently used files, easily accessible via the "C-x C-r" keybinding.

#+begin_src emacs-lisp
(recentf-mode 1)
(setq recentf-max-menu-items 32)
(global-set-key (kbd "C-x C-r") 'recentf-open-files)
#+end_src

** Desktop Save Mode

Most of the times it's convenient that emacs opens previously opened files
when starting up (unless specified files are given as startup arguments).
=desktop-save-mode= does the trick.

#+BEGIN_SRC emacs-lisp
(desktop-save-mode 1)
#+END_SRC

To start emacs without opening last session's files, start it by =emacs --no-desktop=

** Buffers

Give me some help when switching buffers with =C-x b=:

#+BEGIN_SRC emacs-lisp
(setq ido-enable-flex-matching t)
(setq ido-everywhere t)
(ido-mode 1)
#+END_SRC

Also activate window switching with =S-<left>=, =S-<right>=, =S-<up>= and
=S-<down>= :

#+BEGIN_SRC emacs-lisp
(windmove-default-keybindings)
#+END_SRC

Unfortunately this doesn't work nicely with .org files. Therefore, in the org
config, I'm replacing disputed keys.

** Folding

I found a couple of nice things when searching for code folding opportunities:
outline-mode, hide-show, folding-mode and M-x occur among others. But what seems
to work easiest and most robust for me is 'set-selective-display'. This is a
standard function that accepts an optional numerical argument. With the argument
you tell it to 'fold' lines with indent >= argument. I decided to bind it to a
key and toggle between indent 1 and indent 0 which seems to fit 90% of my use
cases:

#+BEGIN_SRC emacs-lisp
(defun mmz/toggle-selective-display (column)
  (interactive "P")
  (set-selective-display
   (if selective-display nil (or column 1))))

(global-set-key (kbd "<f12>") 'mmz/toggle-selective-display)
#+END_SRC

** SQL-mode

When using =M-x sql-postgres= , ask for user, password, server, database and
port. Use these defaults:

#+BEGIN_SRC emacs-lisp
(setq sql-postgres-login-params
      '((user     :default "lms-client")
         password
        (database :default "lms")
        (server   :default "localhost")
        (port     :default 5432)))
#+END_SRC

Furthermore, truncate long lines (needed when rows have lots of data in them).

#+BEGIN_SRC emacs-lisp
(add-hook 'sql-interactive-mode-hook
          (lambda ()
            (toggle-truncate-lines t)))
#+END_SRC

** Imenu: jump to definitions

#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "M-i") 'imenu)
#+END_SRC

** Spelling - Enable / Disable flyspell mode

#+BEGIN_SRC emacs-lisp
(dolist (hook '(text-mode-hook))
  (add-hook hook (lambda () (flyspell-mode 1))))
(dolist (hook '(change-log-mode-hook log-edit-mode-hook))
  (add-hook hook (lambda () (flyspell-mode -1))))
#+END_SRC

* Org-mode
** Display preferences

Pretty bullets instead of asterisks.

#+BEGIN_SRC emacs-lisp
(use-package org-bullets
 :ensure t
 :config (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
#+END_SRC

Nice arrow instead of the usual ellipsis (=...=) when stuff is folded.

#+BEGIN_SRC emacs-lisp
(setq org-ellipsis "⤵")
#+END_SRC

Use syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language’s major mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

** Keybindings

#+begin_src emacs-lisp
(global-set-key "\C-cl" 'org-store-link)
(global-set-key "\C-ca" 'org-agenda)
(global-set-key "\C-cc" 'org-capture)
(global-set-key "\C-cb" 'org-iswitchb)
#+end_src

Don't override the windmove keybindings (=S-<left> <right> <up> & <down>=).

#+BEGIN_SRC emacs-lisp
(add-hook 'org-shiftup-final-hook 'windmove-up)
(add-hook 'org-shiftleft-final-hook 'windmove-left)
(add-hook 'org-shiftdown-final-hook 'windmove-down)
(add-hook 'org-shiftright-final-hook 'windmove-right)
#+END_SRC

** Agenda files

#+BEGIN_SRC emacs-lisp
(setq org-agenda-files
  '("~/org/agenda.org"))
#+END_SRC

** Drawers, logging and clocking

Let's not clutter up our tasks:

#+BEGIN_SRC emacs-lisp
(setq org-log-into-drawer   "LOGBOOK")
(setq org-clock-into-drawer "CLOCK")
#+END_SRC

I don't want to resolve clocks, but simply clock in and clock out when I run the
commands:

#+BEGIN_SRC emacs-lisp
(setq org-clock-idle-time             nil)
(setq org-clock-continuously          nil)
(setq org-clock-persist               nil)
(setq org-clock-in-resume             nil)
(setq org-clock-auto-clock-resolution nil)

(org-clock-persistence-insinuate)
#+END_SRC

Logbook logging:

| Keybinding | Description       |
|------------+-------------------|
| C-c C-z    | Take a Quick note |
| C-c C-c    | Store note        |
|------------+-------------------|

Clocking (time tracking):

| Keybinding      | Description           |
|-----------------+-----------------------|
| C-c C-x C-i     | clock in              |
| C-c C-x C-o     | clock out             |
| C-c C-x C-d     | show times            |
| C-c C-x C-q     | Cancel clock          |
| C-c C-x C-x     | Restart clock         |
| C-u C-c C-x C-x | Restart with menu     |
| C-c C-x C-j     | jump to clocked tasks |
|-----------------+-----------------------|

** Capture

#+BEGIN_SRC emacs-lisp
(setq org-default-notes-file "~/org/capture.org")
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
  '(("e" "Explore"
     entry
     (file+headline org-default-notes-file "Explore")
     "* %?\n")

    ("i" "Idea"
     entry
     (file+headline org-default-notes-file "Ideas")
     "* %?\n")

    ("l" "Listen"
     entry
     (file+headline org-default-notes-file "Listen")
     "* %?\n")

    ("q" "Quote"
     entry
     (file+headline org-default-notes-file "Quotes")
     "* %^{Quote} - %^{Author} (source: %^{Source})")

    ("r" "Read"
     entry
     (file+headline org-default-notes-file "Read")
     "* %?\n")

    ("t" "Todo"
     entry
     (file+headline org-default-notes-file "Tasks")
     "* TODO %?\n")

    ("w" "Watch"
     entry
     (file+headline org-default-notes-file "Watch")
     "* %?\n")))
#+END_SRC

Use ido for completion

#+BEGIN_SRC emacs-lisp
(setq org-refile-use-outline-path t)
(setq org-outline-path-complete-in-steps nil)
#+END_SRC

** Code blocks

Syntax highlighting in source blocks while editing.

#+BEGIN_SRC emacs-lisp
(setq org-src-fontify-natively t)
#+END_SRC

Make TAB act as if it were issued in a buffer of the language's major mode.

#+BEGIN_SRC emacs-lisp
(setq org-src-tab-acts-natively t)
#+END_SRC

When editing a code snippet, use the current window rather than popping open a
new one (which shows the same information).

#+BEGIN_SRC emacs-lisp
(setq org-src-window-setup 'current-window)
#+END_SRC

Allow =babel= to evaluate Emacs lisp:

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages
  'org-babel-load-languages
    '((emacs-lisp . t)))
#+END_SRC

Don't ask before evaluating code blocks.

#+BEGIN_SRC emacs-lisp
(setq org-confirm-babel-evaluate nil)
#+END_SRC

** To-do items

My todo workflow:

#+BEGIN_SRC emacs-lisp
(setq org-todo-keywords
  '((sequence "TODO(t)" "BUSY(b)" "PENDING(p)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC

The items before the pipe ="|"= need action while the items behind it need no
further action. The special characters are:

- =<char>= for fast access key definition (prompted for after =C-c C-t=)
- =!= for adding a timestamp
- =@= for prompting for a note

Change parent item to DONE when all Children are DONE (see: [[https://orgmode.org/manual/Breaking-down-tasks.html#Breaking-down-tasks][Breaking down tasks]] )

Add =[/]= or =[%]= in headline to get tracking of children tasks (n/m and
percentage done respectively)

#+BEGIN_SRC emacs-lisp
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done, to TODO otherwise."
  (let (org-log-done org-log-states)   ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" "TODO"))))
(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC

Checkboxes are not included in the global TODO list and can be used to split a
todo item into a number of simpler tasks:

- [X] plan workflow
- [-] implement workflow
  - [X] add workflow
  - [X] explain workflow
  - [ ] test workflow

** Tags

Tags workflow:

- Add header to the top of a file containing tags and optionally shortcuts:

#+TAGS: IMPORTANT(i) URGENT(u)

- =C-c C-c= to evaluate a newly created tagline
- =C-c C-q= to add a tag to an org-mode header item. Here you can use the
  defined shortcuts. You can add multiple tags on a header item. Nested items
  will inherit the tags added to its parent.
- =C-c / m= for finding matching tags (=C-c a m when you're in an agenda file).
  You can combine tag searches, so for instance search for: IMPORTANT, URGENT,
  IMPORTANT|URGENT or IMPORTANT&URGENT . Results will be highlighted in your
  buffer.
- Edit text or =C-c C-c= to remove highlights.

** Newlines allowed inside marked up expression

Default, =org-mode= only allows markup to span a single newline. I often feel
the need to span a whole paragraph, so I'm increasing this var here to what I
think will be pretty much the max number of consecutive lines I ever want to
mark up.

#+BEGIN_SRC emacs-lisp
(setcar (nthcdr 4 org-emphasis-regexp-components) 128)
(org-set-emph-re 'org-emphasis-regexp-components org-emphasis-regexp-components)
#+END_SRC

More info [[https://emacs.stackexchange.com/questions/13820/inline-verbatim-and-code-with-quotes-in-org-mode][in this stackoverflow answer]] .

* Packages

This configuration uses the [[https://github.com/jwiegley/use-package][use-package]] package from John Wiegley. [[https://www.lunaryorn.com/posts/my-emacs-configuration-with-use-package.html][This blog]]
nicely explains some of the features.

** Smex

Smex adds history and suggestions to M-x

#+begin_src emacs-lisp
(message "%s" "MMz: Start loading smex")
(use-package smex
  :ensure t
  :bind (("M-x"         . smex)
         ("M-X"         . smex-major-mode-commands)
         ("C-c C-c M-x" . execute-extended-command)))
#+end_src

Main Usage:

| Keybinding  | Description                                       |
|-------------+---------------------------------------------------|
| M-x         | Same as old M-x but with history & suggestions    |
| M-X         | Only show commands relevant to current major mode |
| C-c C-c M-x | Link to old M-x command                           |
|-------------+---------------------------------------------------|
| C-h w       | 'Where is' - shows kbd for selected command       |
| C-h f       | Runs 'describe Function' on selected command      |
| M-.         | Jumps to definition of selected command           |
|-------------+---------------------------------------------------|

Links:

- [[https://github.com/nonsequitur/smex][Smex on github (nonsequitur)]]
** Neotree

Neotree shows your directories and files in a tree view.

#+begin_src emacs-lisp
(message "%s" "MMz: Start loading neotree")
(use-package neotree
  :ensure t
  :bind (("<f8>" . neotree-toggle)))
#+end_src

Main Usage:

| Keybinding | Description                      |
|------------+----------------------------------|
| f8         | Toggle neotree                   |
|------------+----------------------------------|
| g          | Refresh neotree                  |
| H          | Toggle display hidden files      |
|------------+----------------------------------|
| C-c C-n    | Create a new file or directory   |
| C-c C-d    | Delete a file or directory       |
| C-c C-r    | Rename a file or directory       |
| C-c C-c    | Change root directory to display |
|------------+----------------------------------|

Links:

- [[https://github.com/jaypei/emacs-neotree][Neotree on Github (jaypei)]]
- [[https://www.emacswiki.org/emacs/NeoTree][Neotree on emacswiki]]
** Engine-Mode

Engine-mode allows me to do internet searches on configured search engines.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading engine-mode")

(use-package engine-mode
  :ensure t)

;; enable engine-mode globally
(engine-mode t)

(defengine amazon
  "https://www.amazon.com/s/ref=nb_sb_noss?field-keywords=%s"
  :keybinding "a")

(defengine clojure-docs
  "https://clojuredocs.org/search?q=%s"
  :keybinding "c")

(defengine dictionary
  "http://www.dictionary.com/browse/%s"
  :keybinding "d")

(defengine google
  "http://www.google.com/search?ie=utf-8&oe=utf-8&q=%s"
  :keybinding "g")

(defengine github
  "https://github.com/search?ref=simplesearch&q=%s"
  :keybinding "h")

(defengine google-images
  "http://www.google.com/images?hl=en&source=hp&biw=1440&bih=795&gbv=2&aq=f&aqi=&aql=&oq=&q=%s"
  :keybinding "i")

(defengine google-maps
  "http://maps.google.com/maps?q=%s"
  :keybinding "m")

(defengine qwant
  "https://www.qwant.com/?q=%s"
  :keybinding "q")

(defengine stack-overflow
  "https://stackoverflow.com/search?q=%s"
  :keybinding "s")

(defengine google-translate
  "https://translate.google.com/#auto/en/%s"
  :keybinding "t")

(defengine wikipedia
  "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
  :keybinding "w")

(defengine youtube
  "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
  :keybinding "y")
#+END_SRC

Main usage:

=C-x / <key for your engine here>= for invoking engine-mode

If your cursor is on a word when invoking engine-mode, that word will
be the default search value unless you overwrite it by typing another
search term.

If you have selected a piece of text (C-SPC ...) and invoke
engine-mode, that piece of text will be your search string.

So for instance I want to search for "emil ernebro" on youtube:

- =C-x / y=
- type "emil ernebro"
- engine-mode will open youtube and search for emil ernebro

Other way to search for "emil ernebro", this time on google-images:

- Select "emil ernebro" in the current textbuffer
- =C-x / i=

Links:

- [[https://github.com/hrs/engine-mode][engine-mode on github (hrs)]]
- [[https://www.youtube.com/watch?v%3DMBhJBMYfWUo][hrs on youtube with short video on engine-mode]]
** Magit

Magit is a brilliant interface to git. It provides several 'popups' (like
commit, push, log, diff) which guide you through the (git) options.

#+begin_src emacs-lisp
(message "%s" "MMz: Start loading magit")

(use-package magit
  :ensure t
  :bind (("C-c g" . magit-status)))
#+end_src

Main Usage:

| Keybinding | Description                         |
|------------+-------------------------------------|
| C-c g      | (ma)git status                      |
|------------+-------------------------------------|
| h          | list all popups + commands          |
| g          | Refresh                             |
| n          | Next section                        |
| p          | Previous section                    |
| TAB        | expand or collapse section at point |
|------------+-------------------------------------|
| s          | stage                               |
| u          | unstage                             |
| c          | commit popup                        |
| C-c C-c    | really commit                       |
| P          | push popup                          |
| u          | push to upstream                    |
|------------+-------------------------------------|
** Rest-Client

I'm using Restclient to test REST calls from text files.
Additional info on [[https://github.com/pashky/restclient.el][github]] (including examples)

#+begin_src emacs-lisp
(message "%s" "MMz: Start loading rest client")

(use-package restclient
  :ensure t)
#+end_src

Main Usage:

| Keybinding | Description                                      |
|------------+--------------------------------------------------|
| C-c C-c    | runs query under cursor, switch to result window |
| C-c C-v    | runs query under cursor, stays in current window |
| C-c C-p    | jump to previous query                           |
| C-c C-n    | jump to next query                               |
| C-c C-.    | mark the query under the cursor                  |
| C-c C-u    | copy query under the cursor as curl cmd          |
|------------+--------------------------------------------------|
** Markdown

Use markdown mode, also for my (old) foldingtext files

#+begin_src emacs-lisp
(message "%s" "MMz: Start loading markdown mode")

(use-package markdown-mode
  :ensure   t
  :commands (markdown-mode gfm-mode)
  :mode     (("README\\.md\\'" . gfm-mode)
             ("\\.md\\'"       . markdown-mode)
             ("\\.markdown\\'" . markdown-mode)
             ("\\.ft\\'"       . markdown-mode))
  :init     (setq markdown-command "multimarkdown"))
#+end_src
** Winner mode

winner-mode lets you use =C-c <left>= and =C-c <right>= to switch between window
configurations. This is handy when something has popped up a buffer that you
want to look at briefly before returning to whatever you were working on. When
you’re done, press =C-c <left>=. [[https://www.youtube.com/watch?v%3DT_voB16QxW0][See winner-mode in action.]]

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading winner mode")

(use-package winner
  :ensure t
  :config (winner-mode 1))
#+END_SRC
** Undo-tree

People often struggle with the Emacs undo model, where there’s really no concept
of “redo” - you simply undo the undo. This package lets you use =C-x u=
(undo-tree-visualize) to visually walk through the changes you’ve made, undo
back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading undo-tree")

(use-package undo-tree
  :ensure t
  :config
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps t)
    (setq undo-tree-visualizer-diff t))
#+END_SRC
** Company

Company is a text completion framework for Emacs. The name stands for "complete
anything". It uses pluggable back-ends and front-ends to retrieve and display
completion candidates.

Main usage:

| keybinding | description                                   |
|------------+-----------------------------------------------|
| <f1>       | Display documentation for selected completion |
| C-w        | Where is? - See source of selected completion |
|------------+-----------------------------------------------|

In addition:

To see a list of enabled backends: =M-x customize-variable RET company-backends=

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading Company")

(use-package company
  :ensure t
  :config (global-company-mode))
#+END_SRC
** Parentheses!

   If parentheses are used, enable paredit and highlight and color them all!

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading everything related to parentheses")

;; Paredit
(use-package paredit
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook                  #'enable-paredit-mode)
  (add-hook 'eval-expression-minibuffer-setup-hook #'enable-paredit-mode)
  (add-hook 'ielm-mode-hook                        #'enable-paredit-mode)
  (add-hook 'lisp-mode-hook                        #'enable-paredit-mode)
  (add-hook 'lisp-interaction-mode-hook            #'enable-paredit-mode)
  (add-hook 'scheme-mode-hook                      #'enable-paredit-mode)
  (add-hook 'clojure-mode-hook                     #'enable-paredit-mode))


;; Ensure paredit is used EVERYWHERE!
(use-package paredit-everywhere
  :ensure t
  :config
  (add-hook 'prog-mode-hook #'paredit-everywhere-mode))

(use-package highlight-parentheses
  :ensure t
  :config
  (add-hook 'emacs-lisp-mode-hook
            (lambda()
              (highlight-parentheses-mode))))

(use-package rainbow-delimiters
  :ensure t
  :config
  (add-hook 'lisp-mode-hook
            (lambda()
              (rainbow-delimiters-mode))))

(global-highlight-parentheses-mode)
#+END_SRC

Main usage:

| Keybinding | Description          | Example                |
|------------+----------------------+------------------------|
| C-M-f      | Move cursor forward  |                        |
| C-M-b      | Move cursor backward |                        |
|------------+----------------------+------------------------|
| C-right    | Forward  slurp       | (1 2) 3 -> (1 2 3)     |
| C-left     | Forward  barf        | (1 2 3) -> (1 2) 3     |
| C-M-right  | Backward barf        | (1 2 3) -> 1 (2 3)     |
| C-M-left   | Backward slurp       | 1 (2 3) -> (1 2 3)     |
|------------+----------------------+------------------------|
| C-k        | Kill until next )    | (1 (_2) 3) -> (1 () 3) |
|------------+----------------------+------------------------|
| M-(        | Wrap around          | (1 2 3) -> (1 (2) 3)   |
| M-s        | Splice               | (1 (2) 3) -> (1 2 3)   |
| M-S        | Split                | (1 2) -> (1) (2)       |
| M-J        | Join                 | (1) (2) -> (1 2)       |
|------------+----------------------+------------------------|

Conceptually, when barfing and slurping, you're moving the =)= in the direction
of the arrow.

Additionally, I had to change the keybindings of my magnet app because they made
heavy use of =C-M= combinations and clashed with the paredit bindings.
** Yasnippet

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading yasnippet")

(use-package yasnippet
  :ensure t
  :config
    (setq yas-snippet-dirs '("~/.emacs.d/snippets/"))
    (yas-global-mode 1))
#+END_SRC

I didn't download any preconfigured snippets and decided to create them
manually when needed. Snippet inspiration can be found [[https://github.com/AndreaCrotti/yasnippet-snippets/tree/master/snippets][here]].

Main Usage:

| Function               | Additional info                             |
|------------------------+---------------------------------------------|
| yas-new-snippet        | C-c C-c to save                             |
| yas-visit-snippet-file | opens snippets definition file              |
|------------------------+---------------------------------------------|
| snippet-mode           | to edit snippets (with syntax highlighting) |
| yas-tryout-snippet     | (in snippet-mode)                           |
|------------------------+---------------------------------------------|

Additional information on [[https://joaotavora.github.io/yasnippet/snippet-development.html][writing snippets]].
** Cider

CIDER is the *C*lojure(Script) *I*nteractive *D*evelopment *E*nvironment that
*R*ocks! [[http://cider.readthedocs.io/en/latest/running_tests/][Read The Docs.]]

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading cider!")

(use-package cider
  :ensure t
  :pin melpa-stable
  :config
    (add-hook 'cider-repl-mode-hook #'company-mode)
    (add-hook 'cider-repl-mode-hook #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-repl-mode-hook #'eldoc-mode)
    (add-hook 'cider-repl-mode-hook #'paredit-mode)
    (add-hook 'cider-repl-mode-hook #'rainbow-delimiters-mode)
    (add-hook 'cider-mode-hook      #'company-mode)
    (add-hook 'cider-mode-hook      #'cider-company-enable-fuzzy-completion)
    (add-hook 'cider-mode-hook      #'eldoc-mode)
    (add-hook 'cider-mode-hook      #'paredit-mode)
    (add-hook 'cider-mode-hook      #'rainbow-delimiters-mode)
    (setq cider-repl-use-pretty-printing t)
;;  (setq nrepl-log-messages t) ;; for debugging / inspecting cider
    (setq cider-test-show-report-on-success t))
#+END_SRC

The config basically configures:

- use (fuzzy) completion in cider modes (also repl)
- use paredit while in clojure mode
- use eldoc in repl mode (displays function signatures in the minibuffer while
  typing)
- Pretty Print when possible
- Log communication with the nREPL server (will create buffers like
  =*nrepl-messages conn-name*=) ->

Main usage:

Open a file belonging to your =lein= or =boot= project (like =core.clj=) and
call the =cider-jack-in= function (=M-x cider-jack-in RET=). This will start an
nREPL server with all the project dependencies loaded in and CIDER will
automatically connect to it.

Alternatively you can use =C-u M-x cider-jack-in RET= to specify the name of a
lein or boot project, without having to visit any file in it. This option is
also useful if your project contains both project.clj and build.boot and you
want to launch a repl for one or the other.

In Clojure(Script) buffers the command cider-jack-in is bound to =C-c M-j=.

Cider Repl & Source Buffer:

| keybinding  | description                                                       |
|-------------+-------------------------------------------------------------------|
| C-c C-d C-a | Apropos- Search (loaded) functions                                |
| C-c C-d C-d | With cursor on function, show documentation.                      |
| C-c C-d C-r | With cursor on function, show grimoire docs (including examples!) |
| M-.         | View source, (M-, to go back again)                               |
| C-c C-z     | Switch to source buffer                                           |
| C-u C-c C-z | Switch to repl and sync namespace with source buffer              |
|             |                                                                   |
|-------------+-------------------------------------------------------------------|

Cider Source Buffer:

| keybinding             | description               | example                                   |
|------------------------+---------------------------+-------------------------------------------|
| C-c C-k                | Load this buffer          |                                           |
| C-c C-e                | Evaluate last sexpression | (inc (+ 2 3)_) -> 5 ; (inc (+ 2 3))_ -> 6 |
| C-c C-c                | Evaluate top level form   | (inc (+ 2 _ 3)) -> 6                      |
|------------------------+---------------------------+-------------------------------------------|
| C-c M-i                | Inspect a value           |                                           |
| C-c M-t v              | Toggle var tracing        |                                           |
| C-c M-t n              | Toggle ns tracing         |                                           |
| C-u C-M-x              | Debug top-level form      |                                           |
| M-x cider-inspect-expr | inspect given expression  |                                           |
|------------------------+---------------------------+-------------------------------------------|
| C-c C-t n              | Run tests in ns           |                                           |
| C-c C-t p              | Run tests in project      |                                           |
|------------------------+---------------------------+-------------------------------------------|

Cider-doc:

| keybinding | description      |
|------------+------------------|
| s          | show source code |
|------------+------------------|


Flows:

- Working in cider repl, cursor on function -> =C-c C-d d= to show documentation
  of function -> =s= to view source -> =M-,= to return to doc view
- Working in cider repl, cursor on function -> =M-.= to show source -> =M-,= to
  go back to repl again.
- Switching between repl and source buffer: =C-c C-z=

Also supercool: =cider-enlighten= to show all intermediate values of a called
function in the source buffer.
** Which-Key

Displays the key bindings following your currently entered incomplete command (a
prefix) in a popup.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading which-key")

(use-package which-key
  :ensure t
  :config
    (which-key-setup-side-window-right-bottom)
    (which-key-mode))
#+END_SRC

=side-window-right-bottom= tries to show key options on the right side of the
screen, but will switch to the bottom if there's not enough space on the right.
=which-key-mode= enables the which-key minor mode.
** Fireplace

MUST HAVE emacs functionality:

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading fireplace")

(use-package fireplace
  :ensure t)
#+END_SRC

- =M-x fireplace= to engage in deep thinking
- =M-x fireplace-off= or =q= to put the fire out
** Expand Region

Expands regions in a =dwim= way.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading expand-region")

(use-package expand-region
  :ensure t
  :bind ("C-@" . er/expand-region))
#+END_SRC

Github repo can be found [[https://github.com/magnars/expand-region.el][here]].
** Web mode

Web mode makes sure you can work with HTML, JavaScript and CSS in one and the
same HTML file.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading web mode")

(use-package web-mode
  :ensure t
  :mode "\\.html?\\'"
  :config
  (progn
    (setq web-mode-markup-indent-offset 2)
    (setq web-mode-code-indent-offset 2)
    (setq web-mode-css-indent-offset 2)
    (setq web-mode-enable-current-element-highlight t)
    (setq web-mode-enable-css-colorization t)
    (setq web-mode-enable-auto-pairing t)))
#+END_SRC
** Emmet mode

Powerful way of creating HTML & CSS snippets.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading emmet mode")

(use-package emmet-mode
  :ensure t
  :commands emmet-mode
  :config
  (add-hook 'web-mode-hook  'emmet-mode)
  (add-hook 'html-mode-hook 'emmet-mode)
  (add-hook 'css-mode-hook  'emmet-mode))
#+END_SRC

- =C-j= is the important keybinding here
- See [[https://emmet.io/][emmet site]] for more info

Some examples:

- =a:link= =C-j= expands to:

#+BEGIN_SRC html
<a href="http://"></a>
#+END_SRC

- =nav>ul>li= =C-j= expands to:

#+BEGIN_SRC html
<nav>
  <ul>
    <li></li>
  </ul>
</nav>
#+END_SRC

-  =.item{$}*3= =C-j= expands to:

#+BEGIN_SRC html
<div class="item">1</div>
<div class="item">2</div>
<div class="item">3</div>
#+END_SRC

- =.container>p*3>lorem5= expands to:

#+BEGIN_SRC html
<div class="container">
  <p>
    Ante metus, dictum at tempor?
  </p>
  <p>
    Feugiat in ante metus, dictum.
  </p>
  <p>
    Semper auctor neque, vitae tempus!
  </p>
</div>
#+END_SRC

More to be found in the [[https://docs.emmet.io/cheatsheet-a5.pdf][huge cheatsheet (pdf)]].
** flycheck & clj-kondo

First make sure clj-kondo is installed. Instructions:
https://github.com/borkdude/clj-kondo/blob/master/doc/install.md

Basically: ~brew install borkdude/brew/clj-kondo~
To upgrade: ~brew upgrade clj-kondo~

Additional instructions (e.g. running clj-kondo as a leiningen command):
https://github.com/borkdude/clj-kondo/blob/master/doc/

Then hook it up to FlyCheck: https://github.com/borkdude/flycheck-clj-kondo

This will only work if flycheck is installed ~M-x package-list-packages~ and
clj-kondo is on your path. ~which clj-kondo~

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading flycheck")

(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading flycheck-clj-kondo")

(use-package flycheck-clj-kondo
  :ensure t)
#+END_SRC

Require clj-kondo as soon as `clojure-mode` is loaded

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading clojure mode")

(use-package clojure-mode
  :ensure t
  :config
  (require 'flycheck-clj-kondo))
#+END_SRC
** clj-refactor

A package to refactor Clojure Code:
https://github.com/clojure-emacs/clj-refactor.el/wiki

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading clj-refactor")

(use-package clj-refactor
  :ensure t
  :init (add-hook 'clojure-mode-hook (lambda () (clj-refactor-mode 1))))
#+END_SRC
** Deft

Deft is an Emacs mode for quickly browsing, filtering, and editing directories
of plain text notes.

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: Start loading deft")

(use-package deft
  :ensure   t
  :bind     ("C-M-z" . deft)
  :commands (deft)
  :config   (setq deft-directory  "~/org/notes")
            (setq deft-extensions '("md" "org"))
            (setq deft-recursive  t))
#+END_SRC

* Upgrading Packages

Packages are stored in ~.dotfiles/emacs/.emacs.d/elpa/~ with their version as
part of the folder name. Packages aren't upgraded automatically (by choice;
there are packages that auto update, but I want to decide when and how to
upgrade). To upgrade:

- Backup your ~.dotfiles/emacs/.emacs.d/elpa/~ folder so you always can go back
  to a working situation
- ~M-x list-packages~ to see the list of packages available
- ~U~ to mark available upgrades. If there are packages that can be upgraded,
  emacs proposes to delete the old version of that new package.
- ~SPC~ to browse
- ~RET~ on a package to inspect it
- mark the packages you want to upgrade with ~i~ (install)
- mark the packages you want to delete with ~d~ (delete)
- when done, hit ~x~ to execute
- if applicable emacs suggest to run a ~M-x package-autoremove~ to remove old
  packages and unused dependencies.
- Restart emacs
- Check if the emacs install is still ok, by following the [[Debugging][Debugging]]
  instructions.

* Debugging

Sometimes adding a package doesn't work as expected. In those cases you can try
several things:

- Try starting emacs from the terminal with ~emacs --debug-init~
- Set ~use-package-verbose~ to ~t~ . Errors occuring while initializing or
  configuring a package will not stop emacs from loading. With this setting the
  errors will be reported to a special ~*Warnings*~ popup buffer so you can debug
  the package loading.
- Try ~package-refresh-contents~ or check if the troublesome package is in
  ~package-list-packages~

- When adding a new 'use-package' emacs-lisp code block in config.org, you can
  check the syntax, by moving point behind the last bracket and then running
  ~M-x pp-macroexpand-last-sexp~ .

- It's possible to open ~/.emacs.d/config.el and ~M-x flycheck-compile~ to see
  all errors and warnings.

- Try ~M-x eval-buffer~ when in the buffer of ~/.emacs.d/init.el

* Try?

- [[https://github.com/zenozeng/yafolding.el][yafolding]]? ... Problem with current indent based folding is that it doesn't
  fold comments (see folding header). So new solution should fix that.
- [[https://github.com/magnars/multiple-cursors.el/blob/master/README.md][multiple cursors]]
- [[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/][Complete guide to email in emacs using mu and mu4e]]
- http://www.skybert.net/emacs/bash-linting-in-emacs/
- [[https://github.com/tarsius/moody][moody?]]

* Cleanup?
* End

#+BEGIN_SRC emacs-lisp
(message "%s" "MMz: End of Emacs Config")
(provide 'config)
;;; config.el ends here
#+END_SRC
